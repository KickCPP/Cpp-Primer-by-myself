## [10.1](ex10-1.cpp)
## 10.4
存在错误，因为求和的结果是整数，应该改为：
```cpp
accumulate(v.cbegin(), v.cend(), 0.0);
```
## 10.5
比较字符串实际上比较的是两个字符数组的临时地址
## 10.6
## 10.7
两个修改见程序，b)中`vec`原来大小为0，故`fill_n`是不能改变`vec`容器的大小，即实际上是没有写数据的，容器仍然为空
## 10.8
`back_inserter`属于`<iterator>`，并不属于`<algorithm>`
## [10.9](ex10-9.cpp)
## 10.10
因为是泛型算法，其不知道容器类型，无法具体地改变容器大小。泛型算法的设计就是在迭代器的基础上进行操作，而不操作容器
## [10.11](ex10-11.cpp)
## [10.14](ex10-14.cpp)
## [10.16](ex10-16.cpp)
## [10.20](ex10-20.cpp)
## [10.22](ex10-22.cpp)
## 10.23
`bind`接收的第一个参数是被绑定的函数本身，后面的参数的数目，取决于被绑定函数的参数数目
## [10.24](ex10-24.cpp)
## 10.26
* `back_inserter`使用`push_back`
* `front_inserter`使用`push_front`
* `inserter`使用`insert`
## [10.27](ex10-27.cpp)
## [10.29](ex10-29.cpp)
## [10.30](ex10-30.cpp)
## [10.31](ex10-31.cpp)
## [10.33](ex10-33.cpp)
## [10.34](ex10-34.cpp)
## [10.35](ex10-35.cpp)
## [10.36](ex10-36.cpp)
## [10.37](ex10-37.cpp)
## 10.38
* 输入迭代器，`==`,`!=`,`++`,`*`,`->`；由于不能保存输入迭代器的状态，只能单遍扫描，只读。
* 输出迭代器，`++`,`*`；不能保存输出迭代器的状态，只能赋值一次，只能单遍扫描，只写。
* 前向迭代器，`==`,`!=`,`++`,`*`,`->`；多次读写一个元素，能够保存前向迭代器的状态，多遍扫描，读写。
* 双向迭代器，`==`,`!=`,`--`,`++`,`*`,`->`；能支持前向迭代器的所有操作，而且支持双向扫描。
* 随机访问迭代器，支持双向迭代器支持的所有功能，还提供随机访问元素的能力：`==`,`!=`,`--`,`++`,`*`,`->`,`>`,`>=`,`<`,`<=`,`+`,`+=`,`-`,`-=`,`-(两个迭代器之间)`,`[]`。

## 10.39
`list`上的迭代器属于双向迭代器  
`vector`上的迭代器属于随机访问迭代器
## 10.40
`copy`的前两个迭代器要求输入迭代器，最后一个迭代器要求输出迭代器  
`reverse`的两个迭代器要求双向迭代器   
`unique`的两个迭代器是前向迭代器，最终也会返回前向迭代器
## 10.41
```cpp
//将范围内的所有元素中的old_val替换为new_val
replace(beg, end, old_val, new_val);
//将范围内让pred为true的元素替换为new_val
replace_if(beg, end, pred, new_val);
//将[begin, end)范围内的oldval替换为new_val并拷贝到dest开始的范围中，原来的范围中的元素不变
replace_copy(beg, end, dest, old_val, new_val);
//将[begin, end)范围中令pred为真的元素都替换为new_val然后将所有元素拷贝到dest开始的范围中，原来的范围中的元素不变
replace_copy_if(beg, end, dest, pred, new_val); 
```
## [10.42](10-42.cpp)